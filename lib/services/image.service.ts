import "server-only";

import { BaseService, ValidationError, NotFoundError } from "./base.service";
import { uploadToR2, deleteFromR2, extractKeyFromUrl, R2UploadOptions, UploadResult, sanitizeFilenameForMetadata } from "@/lib/r2";

export interface ImageRecord {
  id: string;
  organizationId: string;
  entityType: string;
  entityId?: string;
  originalName: string;
  fileName: string;
  fileSize: number;
  contentType: string;
  r2Key: string;
  publicUrl: string;
  uploadedBy: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateImageInput {
  organizationId: string;
  entityType: "product" | "combo" | "packaging" | "organization" | "user";
  entityId?: string;
  file: Buffer;
  originalName: string;
  contentType: string;
  uploadedBy: string;
}

export class ImageService extends BaseService {
  /**
   * Upload image and save record to database
   */
  async uploadImage(data: CreateImageInput): Promise<{ image: ImageRecord; uploadResult: UploadResult }> {
    await this.verifyOrganizationAccess(data.organizationId, data.uploadedBy);

    // Get organization for slug
    const organization = await this.prisma.organization.findUnique({
      where: { id: data.organizationId },
      select: { slug: true },
    });

    if (!organization) {
      throw new NotFoundError("Organization");
    }

    // Prepare R2 upload options
    const uploadOptions: R2UploadOptions = {
      organizationSlug: organization.slug,
      entityType: data.entityType,
      entityId: data.entityId,
      fileName: data.originalName,
      contentType: data.contentType,
      metadata: {
        'uploaded-by-user': data.uploadedBy,
        'original-name': data.originalName,
        'entity-type': data.entityType,
        'entity-id': data.entityId || '',
      },
    };

    try {
      // Upload to R2
      const uploadResult = await uploadToR2(data.file, uploadOptions);

      // Save image record to database (if you have an images table)
      // For now, we'll return the upload result
      // You could create an images table to track all uploaded files

      const imageRecord: ImageRecord = {
        id: `img_${Date.now()}`, // Would be generated by database
        organizationId: data.organizationId,
        entityType: data.entityType,
        entityId: data.entityId,
        originalName: data.originalName,
        fileName: uploadResult.key.split('/').pop() || data.originalName,
        fileSize: uploadResult.size,
        contentType: uploadResult.contentType,
        r2Key: uploadResult.key,
        publicUrl: uploadResult.publicUrl,
        uploadedBy: data.uploadedBy,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      return {
        image: imageRecord,
        uploadResult,
      };

    } catch (error) {
      this.handlePrismaError(error, "Image upload");
    }
  }

  /**
   * Delete image from R2 and database
   */
  async deleteImage(organizationId: string, imageUrl: string, userId: string): Promise<void> {
    await this.verifyOrganizationAccess(organizationId, userId);

    // Extract R2 key from URL
    const r2Key = extractKeyFromUrl(imageUrl);
    if (!r2Key) {
      throw new ValidationError("Invalid image URL");
    }

    // Get organization for verification
    const organization = await this.prisma.organization.findUnique({
      where: { id: organizationId },
      select: { slug: true },
    });

    if (!organization) {
      throw new NotFoundError("Organization");
    }

    // Verify the image belongs to this organization
    if (!r2Key.startsWith(`${organization.slug}/`)) {
      throw new ValidationError("Image does not belong to this organization");
    }

    try {
      // Delete from R2
      await deleteFromR2(r2Key);

      // If you have an images table, delete the record here
      // await this.prisma.image.delete({ where: { r2Key, organizationId } });

    } catch (error) {
      this.handlePrismaError(error, "Image deletion");
    }
  }

  /**
   * Update product images
   */
  async updateProductImages(
    productId: string,
    organizationId: string,
    imageUrls: string[],
    userId: string
  ): Promise<void> {
    await this.verifyOrganizationAccess(organizationId, userId);

    // Verify product exists and belongs to organization
    const product = await this.prisma.product.findFirst({
      where: { id: productId, organizationId },
    });

    if (!product) {
      throw new NotFoundError("Product");
    }

    try {
      // In a real implementation, you might have a ProductImages table
      // For now, we could store images as JSON in the product record
      // or create a separate images table with product relations

      // Example: Update product with image URLs
      await this.prisma.product.update({
        where: { id: productId },
        data: {
          // Store as JSON or create separate image relations
          // images: imageUrls, // If you add an images field
          updatedAt: new Date(),
        },
      });

    } catch (error) {
      this.handlePrismaError(error, "Product images update");
    }
  }

  /**
   * Update combo images
   */
  async updateComboImages(
    comboId: string,
    organizationId: string,
    imageUrls: string[],
    userId: string
  ): Promise<void> {
    await this.verifyOrganizationAccess(organizationId, userId);

    // Verify combo exists and belongs to organization
    const combo = await this.prisma.productCombo.findFirst({
      where: { id: comboId, organizationId },
    });

    if (!combo) {
      throw new NotFoundError("Product combo");
    }

    try {
      // Update combo with image URLs
      await this.prisma.productCombo.update({
        where: { id: comboId },
        data: {
          // Store as JSON or create separate image relations
          // images: imageUrls, // If you add an images field
          updatedAt: new Date(),
        },
      });

    } catch (error) {
      this.handlePrismaError(error, "Combo images update");
    }
  }

  /**
   * Get images for an entity
   */
  async getEntityImages(
    organizationId: string,
    entityType: string,
    entityId: string,
    userId: string
  ): Promise<string[]> {
    await this.verifyOrganizationAccess(organizationId, userId);

    // In a real implementation, you would query an images table
    // For now, return empty array or implement based on your schema

    try {
      switch (entityType) {
        case "product":
          const product = await this.prisma.product.findFirst({
            where: { id: entityId, organizationId },
            // select: { images: true }, // If you have an images field
          });
          return []; // product?.images || [];

        case "combo":
          const combo = await this.prisma.productCombo.findFirst({
            where: { id: entityId, organizationId },
            // select: { images: true }, // If you have an images field
          });
          return []; // combo?.images || [];

        default:
          return [];
      }
    } catch (error) {
      this.handlePrismaError(error, "Get entity images");
    }
  }

  /**
   * Clean up orphaned images (images not referenced by any entity)
   */
  async cleanupOrphanedImages(organizationId: string, userId: string): Promise<{
    deletedCount: number;
    errors: string[];
  }> {
    await this.verifyOrganizationAccess(organizationId, userId);

    // This would require a proper images table to track which images
    // are referenced by which entities. For now, return empty result.

    return {
      deletedCount: 0,
      errors: [],
    };
  }

  /**
   * Get storage usage statistics for organization
   */
  async getStorageStats(organizationId: string, userId: string): Promise<{
    totalSize: number;
    imageCount: number;
    avgImageSize: number;
    byEntityType: Record<string, { count: number; size: number }>;
  }> {
    await this.verifyOrganizationAccess(organizationId, userId);

    // This would require tracking image metadata in database
    // For now, return default stats

    return {
      totalSize: 0,
      imageCount: 0,
      avgImageSize: 0,
      byEntityType: {},
    };
  }
}

export const imageService = new ImageService();
