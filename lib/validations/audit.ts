import * as z from "zod";
import { cuidSchema, paginatedQuerySchema } from "./common";
import { permissionActionSchema, resourceTypeSchema } from "./auth";

// ===== AUDIT LOG SCHEMAS =====

export const auditActionSchema = z.enum([
  "CREATE", "UPDATE", "DELETE", "RESTORE", "ARCHIVE",
  "LOGIN", "LOGOUT", "INVITE", "ACCEPT_INVITATION", "DECLINE_INVITATION",
  "UPLOAD", "DOWNLOAD", "EXPORT", "IMPORT",
  "GRANT_PERMISSION", "REVOKE_PERMISSION", "CHANGE_ROLE",
  "BILLING_UPDATE", "SUBSCRIPTION_CHANGE", "PAYMENT_PROCESSED",
  "SETTINGS_UPDATE", "BACKUP_CREATED", "BACKUP_RESTORED"
], {
  errorMap: () => ({ message: "Invalid audit action" })
});

export const auditResultSchema = z.enum(["SUCCESS", "FAILURE", "PARTIAL"], {
  errorMap: () => ({ message: "Invalid audit result" })
});

export const auditSeveritySchema = z.enum(["LOW", "MEDIUM", "HIGH", "CRITICAL"], {
  errorMap: () => ({ message: "Invalid audit severity" })
});

// Base audit log entry
export const auditLogEntrySchema = z.object({
  id: cuidSchema.optional(), // Generated by database
  organizationId: cuidSchema,
  userId: cuidSchema.optional(), // Can be null for system actions
  sessionId: z.string().optional(),
  action: auditActionSchema,
  resource: resourceTypeSchema,
  resourceId: cuidSchema.optional(),
  result: auditResultSchema,
  severity: auditSeveritySchema.default("LOW"),
  
  // Details about what changed
  changes: z.object({
    before: z.record(z.any()).optional(),
    after: z.record(z.any()).optional(),
    delta: z.record(z.any()).optional(), // Only the fields that changed
  }).optional(),
  
  // Context information
  context: z.object({
    ipAddress: z.string().ip().optional(),
    userAgent: z.string().max(1000).optional(),
    location: z.object({
      country: z.string().optional(),
      region: z.string().optional(),
      city: z.string().optional(),
    }).optional(),
    device: z.object({
      type: z.enum(["desktop", "mobile", "tablet", "unknown"]).optional(),
      os: z.string().optional(),
      browser: z.string().optional(),
    }).optional(),
  }).optional(),
  
  // Additional metadata
  metadata: z.object({
    duration: z.number().optional(), // Operation duration in milliseconds
    fileSize: z.number().optional(), // For file operations
    recordCount: z.number().optional(), // For batch operations
    errorCode: z.string().optional(), // For failed operations
    errorMessage: z.string().optional(),
    tags: z.array(z.string()).optional(),
    correlationId: z.string().optional(), // For linking related operations
  }).optional(),
  
  timestamp: z.date().default(() => new Date()),
  expiresAt: z.date().optional(), // For automatic cleanup
});

// Create audit log entry (for API)
export const createAuditLogSchema = auditLogEntrySchema.omit({ 
  id: true, 
  timestamp: true 
});

// ===== AUDIT QUERY SCHEMAS =====

export const auditLogQuerySchema = paginatedQuerySchema.extend({
  organizationId: cuidSchema,
  userId: cuidSchema.optional(),
  action: z.array(auditActionSchema).optional(),
  resource: z.array(resourceTypeSchema).optional(),
  result: z.array(auditResultSchema).optional(),
  severity: z.array(auditSeveritySchema).optional(),
  dateFrom: z.coerce.date().optional(),
  dateTo: z.coerce.date().optional(),
  resourceId: cuidSchema.optional(),
  ipAddress: z.string().ip().optional(),
  tags: z.array(z.string()).optional(),
  correlationId: z.string().optional(),
}).superRefine((data, ctx) => {
  // Business rule: dateTo must be after dateFrom
  if (data.dateFrom && data.dateTo && data.dateTo <= data.dateFrom) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "End date must be after start date",
      path: ["dateTo"],
    });
  }
  
  // Business rule: date range cannot exceed 90 days
  if (data.dateFrom && data.dateTo) {
    const diffInDays = Math.ceil((data.dateTo.getTime() - data.dateFrom.getTime()) / (1000 * 60 * 60 * 24));
    if (diffInDays > 90) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Date range cannot exceed 90 days",
        path: ["dateTo"],
      });
    }
  }
});

// Advanced audit analytics
export const auditAnalyticsQuerySchema = z.object({
  organizationId: cuidSchema,
  dateFrom: z.coerce.date(),
  dateTo: z.coerce.date(),
  groupBy: z.enum(["action", "resource", "user", "day", "hour"]).default("day"),
  metrics: z.array(z.enum(["count", "success_rate", "avg_duration", "unique_users"])).default(["count"]),
  filters: z.object({
    actions: z.array(auditActionSchema).optional(),
    resources: z.array(resourceTypeSchema).optional(),
    users: z.array(cuidSchema).optional(),
    severity: z.array(auditSeveritySchema).optional(),
  }).optional(),
}).superRefine((data, ctx) => {
  // Business rule: dateTo must be after dateFrom
  if (data.dateTo <= data.dateFrom) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "End date must be after start date",
      path: ["dateTo"],
    });
  }
});

// ===== SECURITY EVENT SCHEMAS =====

export const securityEventTypeSchema = z.enum([
  "SUSPICIOUS_LOGIN", "MULTIPLE_FAILED_LOGINS", "UNUSUAL_LOCATION",
  "PERMISSION_ESCALATION", "BULK_DATA_ACCESS", "AFTER_HOURS_ACCESS",
  "FAILED_PERMISSION_CHECK", "ACCOUNT_LOCKOUT", "PASSWORD_BREACH_ATTEMPT",
  "API_RATE_LIMIT_EXCEEDED", "UNUSUAL_FILE_ACCESS", "DATA_EXPORT_LARGE"
], {
  errorMap: () => ({ message: "Invalid security event type" })
});

export const securityEventSchema = z.object({
  id: cuidSchema.optional(),
  organizationId: cuidSchema,
  userId: cuidSchema.optional(),
  eventType: securityEventTypeSchema,
  severity: auditSeveritySchema,
  description: z.string().min(1).max(1000),
  riskScore: z.number().min(0).max(100), // 0-100 risk score
  
  // Related audit logs
  relatedAuditIds: z.array(cuidSchema).optional(),
  
  // Detection details
  detection: z.object({
    rule: z.string(), // Which rule detected this
    confidence: z.number().min(0).max(1), // 0-1 confidence score
    falsePositive: z.boolean().default(false),
    verifiedThreat: z.boolean().default(false),
  }),
  
  // Response actions
  response: z.object({
    status: z.enum(["OPEN", "INVESTIGATING", "RESOLVED", "FALSE_POSITIVE"]).default("OPEN"),
    assignedTo: cuidSchema.optional(),
    actions: z.array(z.string()).default([]),
    notes: z.string().max(2000).optional(),
    resolvedAt: z.date().optional(),
  }).optional(),
  
  // Context (inherits from audit log)
  context: auditLogEntrySchema.shape.context,
  metadata: auditLogEntrySchema.shape.metadata,
  
  timestamp: z.date().default(() => new Date()),
  expiresAt: z.date().optional(),
});

// ===== COMPLIANCE SCHEMAS =====

export const complianceStandardSchema = z.enum([
  "GDPR", "CCPA", "SOX", "HIPAA", "ISO27001", "PCI_DSS", "SOC2"
], {
  errorMap: () => ({ message: "Invalid compliance standard" })
});

export const complianceRequirementSchema = z.object({
  standard: complianceStandardSchema,
  requirement: z.string().min(1).max(100),
  description: z.string().max(500),
  mandatory: z.boolean().default(true),
  auditActions: z.array(auditActionSchema), // Which actions satisfy this requirement
  retentionPeriod: z.number().min(1), // Days to retain logs for this requirement
});

export const complianceReportSchema = z.object({
  organizationId: cuidSchema,
  standard: complianceStandardSchema,
  dateFrom: z.coerce.date(),
  dateTo: z.coerce.date(),
  includeDetails: z.boolean().default(false),
  format: z.enum(["JSON", "CSV", "PDF"]).default("JSON"),
  requirements: z.array(z.string()).optional(), // Specific requirements to include
});

// ===== DATA RETENTION SCHEMAS =====

export const retentionPolicySchema = z.object({
  organizationId: cuidSchema,
  resource: resourceTypeSchema,
  retentionDays: z.number().min(1).max(2555), // Max ~7 years
  autoDelete: z.boolean().default(false),
  archiveBeforeDelete: z.boolean().default(true),
  complianceStandards: z.array(complianceStandardSchema).default([]),
  createdBy: cuidSchema,
  isActive: z.boolean().default(true),
});

export const dataCleanupJobSchema = z.object({
  organizationId: cuidSchema.optional(), // Null for global cleanup
  resource: resourceTypeSchema.optional(), // Null for all resources
  cutoffDate: z.date(),
  dryRun: z.boolean().default(true),
  batchSize: z.number().min(1).max(10000).default(1000),
  deleteArchived: z.boolean().default(false),
});

// ===== TYPE EXPORTS =====

export type AuditAction = z.infer<typeof auditActionSchema>;
export type AuditResult = z.infer<typeof auditResultSchema>;
export type AuditSeverity = z.infer<typeof auditSeveritySchema>;
export type AuditLogEntry = z.infer<typeof auditLogEntrySchema>;
export type CreateAuditLogInput = z.infer<typeof createAuditLogSchema>;

export type AuditLogQuery = z.infer<typeof auditLogQuerySchema>;
export type AuditAnalyticsQuery = z.infer<typeof auditAnalyticsQuerySchema>;

export type SecurityEventType = z.infer<typeof securityEventTypeSchema>;
export type SecurityEvent = z.infer<typeof securityEventSchema>;

export type ComplianceStandard = z.infer<typeof complianceStandardSchema>;
export type ComplianceRequirement = z.infer<typeof complianceRequirementSchema>;
export type ComplianceReport = z.infer<typeof complianceReportSchema>;

export type RetentionPolicy = z.infer<typeof retentionPolicySchema>;
export type DataCleanupJob = z.infer<typeof dataCleanupJobSchema>;
